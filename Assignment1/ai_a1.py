# -*- coding: utf-8 -*-
"""AI-A1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Gazv2xH9uoRkobQoXgMNhUGeLqUmsvt1
"""

# Commented out IPython magic to ensure Python compatibility.
# importing
import csv
import numpy as np
from copy import copy
import sys
import numpy
numpy.set_printoptions(threshold=sys.maxsize)
import random
import urllib.request as ul
import re, math, sys
import matplotlib.pyplot as plt
# %matplotlib inline

#Reading a file
filename="pr76.tsp"
data = open(filename,'r')

coord_section = False
cord = {}
for line in data.readlines ():
    if re.match ('NODE_COORD_SECTION.*', line):
        coord_section = True
        continue
    elif re.match ('EOF.*', line):
        break
    if coord_section:
        coord = " ".join(line.split())
        coord = coord.split(' ')
        index = int   (coord [0])
        cx    = float (coord [1])
        cy    = float (coord [2])
        cord[index] = (cx, cy)
data.close ()


index=[]
for i,j in enumerate(cord.keys()):
    index.append(j)

def splitListOfTuples(lst):
    lst1 = []
    lst2 = []
    for x, y in lst:
        lst1.append(float(x))
        lst2.append(float(y))
    return (lst1, lst2)

for k in cord.keys():
    for i in cord.get(k):
       x, y = splitListOfTuples(cord.values())

print(index)
print(x)
print(y)

# Functions for distance, matrix forming, length of route
def distance(x1,y1 ,x2,y2):
  dist = np.sqrt(np.square(x1-x2) + np.square(y1-y2))
  return dist

def tsp_matrix(x,y):
  tsp = []
  temp = []
  for i in range(len(x)):
    temp.clear()
    for j in range(len(x)):
      temp.append(distance(x[i],y[i] ,x[j],y[j]))
    t = copy(temp)
    tsp.append(t)
  return tsp

def route_length(tsp, solution):
  length = 0
  for i in range(len(solution)):
    length += tsp[solution[i-1]][solution[i]]
  return length

# calculating for random solution
def random_solution(tsp):
  cities = list(range(len(tsp)))
  result = []

  for i in range(len(tsp)):
    random_city = cities[random.randint(0,len(cities)-1)]
    result.append(random_city)
    cities.remove(random_city)

  return result

tsp = tsp_matrix(x,y)
rands = random_solution(tsp)
print(f"Path for random solution: {random_solution(tsp)}")
print(f"Distance for random solution: {route_length(tsp,rands)}")

# Finding neighbors
def find_neighbors(sol):
  neighbors = []
  for i in range(len(sol)):
    for j in range(i+1,len(sol)):
      a = sol.copy()
      a[i] = sol[j]
      a[j] = sol[i]
      neighbors.append(a)
  return neighbors
solution = random_solution(tsp)

def find_best_neighbor(tsp , neighbors):
  best_neighbor_length = route_length(tsp, neighbors[0]) 
  best_neighbor = neighbors[0]

  for i in neighbors:
    current_length = route_length(tsp , i)
    if current_length < best_neighbor_length :
      best_neighbor_length = current_length
      best_neighbor = i
  
  return best_neighbor, best_neighbor_length
  
# calculating for hill climbing
def hill_climbing(tsp):
  dist = []
  solution = random_solution(tsp)
  length = route_length(tsp,solution)
  neighbors = find_neighbors(solution)
  best_neighbor , best_neighbor_length = find_best_neighbor(tsp , neighbors)
  while best_neighbor_length < length :
    current_solution = best_neighbor
    length = best_neighbor_length
    dist.append(length)
    neighbors = find_neighbors(current_solution)
    best_neighbor , best_neighbor_length = find_best_neighbor(tsp , neighbors)
  return current_solution , length, dist

hill_solution, hill_dist , dist= hill_climbing(tsp) 
print(f"Path for hill climbing is {hill_solution}")
print(f"Distance for hill climbing is {hill_dist}")

result = []
for i in range(0, len(hill_solution)):
  result.append(str(hill_solution[i]))
import pandas as pd
df = pd.DataFrame({"path":result})
df.to_csv("solution.csv",index=False)

iteration = []
def plot_dist(dist): 
  
  for i in range(1,len(dist)+1):
    iteration.append(i)
  plt.plot(iteration, dist, '-', color='black');
tsp = tsp_matrix(x,y)

plot_dist(dist)

x_len = len(iteration) # x-position of annotation
y_len = max(dist) # y-position of annotation

#plot for Random Solution
plt.plot(min(iteration), max(dist), 'o', color='red')
plt.annotate("Random Solution", xy=(0, max(dist)), xytext=(x_len/4,y_len), arrowprops={"arrowstyle":"->", "color":"black"})

#plot for Hill Climbing
plt.plot(max(iteration), min(dist), 'o',color='red')
plt.annotate("Hill Climbing", xy=(max(iteration), min(dist)), xytext=(x_len*0.75, y_len/2), arrowprops={"arrowstyle":"->", "color":"black"})

plt.xlabel("Iteration")
plt.ylabel("Distance")

